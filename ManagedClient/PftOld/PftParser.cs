//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Pft.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace ManagedClient.Pft {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class PftParser : Parser {
	public const int
		T__38=1, T__37=2, T__36=3, T__35=4, T__34=5, T__33=6, T__32=7, T__31=8, 
		T__30=9, T__29=10, T__28=11, T__27=12, T__26=13, T__25=14, T__24=15, T__23=16, 
		T__22=17, T__21=18, T__20=19, T__19=20, T__18=21, T__17=22, T__16=23, 
		T__15=24, T__14=25, T__13=26, T__12=27, T__11=28, T__10=29, T__9=30, T__8=31, 
		T__7=32, T__6=33, T__5=34, T__4=35, T__3=36, T__2=37, T__1=38, T__0=39, 
		SIGNED=40, UNSIGNED=41, FORMATEXIT=42, FLOAT=43, LITERALQUOTE=44, ESCAPED=45, 
		UNCONDITIONAL=46, CONDITIONAL=47, REPEATABLE=48, FIELD=49, GLOBALVAR=50, 
		MODESWITCH=51, MFNWITHLENGTH=52, INCLUSION=53, COMMANDC=54, COMMANDX=55, 
		A=56, AND=57, AT=58, BANG=59, BREAK=60, COLON=61, COMMA=62, DEBUG=63, 
		ELSE=64, EQUALS=65, ERROR=66, F=67, FATAL=68, FI=69, HASH=70, IF=71, IOCC=72, 
		L=73, LAST=74, LESS=75, LESSEQ=76, LPAREN=77, MFN=78, MINUS=79, MORE=80, 
		MOREEQ=81, NOCC=82, NOT=83, NOTEQUALS=84, OR=85, P=86, PERCENT=87, PLUS=88, 
		RAVR=89, REF=90, RMAX=91, RMIN=92, RPAREN=93, RSUM=94, S=95, SEMICOLON=96, 
		SLASH=97, STAR=98, THEN=99, TILDA=100, TRACE=101, TRIM=102, VAL=103, WARNING=104, 
		WS=105, COMMENT=106;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'beep'", "'left'", "'clientVersion'", "'msg'", "'ask'", 
		"'chr'", "'pad'", "'npost'", "'padright'", "'system'", "'mid'", "'requireClient'", 
		"'tolower'", "'trimright'", "'getenv'", "'size'", "'message'", "'cat'", 
		"'host'", "'port'", "'mstname'", "'toupper'", "'date'", "'database'", 
		"'now'", "'replace'", "'trimleft'", "'user'", "'include'", "'serverVersion'", 
		"'proc'", "'type'", "'padleft'", "'time'", "'right'", "'requireServer'", 
		"'putenv'", "'organization'", "'ord'", "SIGNED", "UNSIGNED", "FORMATEXIT", 
		"FLOAT", "LITERALQUOTE", "ESCAPED", "UNCONDITIONAL", "CONDITIONAL", "REPEATABLE", 
		"FIELD", "GLOBALVAR", "MODESWITCH", "MFNWITHLENGTH", "INCLUSION", "COMMANDC", 
		"COMMANDX", "A", "AND", "'@'", "'!'", "BREAK", "':'", "','", "DEBUG", 
		"ELSE", "'='", "ERROR", "F", "FATAL", "FI", "'$'", "IF", "IOCC", "L", 
		"'LAST'", "'<'", "'<='", "'('", "MFN", "'-'", "'>'", "'>='", "NOCC", "NOT", 
		"'<>'", "OR", "P", "'%'", "'+'", "RAVR", "REF", "RMAX", "RMIN", "')'", 
		"RSUM", "S", "';'", "'/'", "'*'", "THEN", "'~'", "TRACE", "TRIM", "VAL", 
		"WARNING", "WS", "COMMENT"
	};
	public const int
		RULE_program = 0, RULE_statement = 1, RULE_groupStatement = 2, RULE_nonGrouped = 3, 
		RULE_formatElement = 4, RULE_leftHand = 5, RULE_rigthHand = 6, RULE_conditionalStatement = 7, 
		RULE_condition = 8, RULE_stringTest = 9, RULE_arithCondition = 10, RULE_arithExpr = 11, 
		RULE_value = 12, RULE_arithFunction = 13, RULE_fieldPresense = 14;
	public static readonly string[] ruleNames = {
		"program", "statement", "groupStatement", "nonGrouped", "formatElement", 
		"leftHand", "rigthHand", "conditionalStatement", "condition", "stringTest", 
		"arithCondition", "arithExpr", "value", "arithFunction", "fieldPresense"
	};

	public override string GrammarFileName { get { return "Pft.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public PftParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgramContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode Eof() { return GetToken(PftParser.Eof, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 33;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__38) | (1L << T__37) | (1L << T__36) | (1L << T__35) | (1L << T__34) | (1L << T__33) | (1L << T__32) | (1L << T__30) | (1L << T__29) | (1L << T__28) | (1L << T__27) | (1L << T__26) | (1L << T__25) | (1L << T__24) | (1L << T__22) | (1L << T__21) | (1L << T__20) | (1L << T__19) | (1L << T__18) | (1L << T__17) | (1L << T__16) | (1L << T__15) | (1L << T__14) | (1L << T__13) | (1L << T__12) | (1L << T__11) | (1L << T__10) | (1L << T__9) | (1L << T__8) | (1L << T__7) | (1L << T__6) | (1L << T__5) | (1L << T__4) | (1L << T__3) | (1L << T__2) | (1L << T__1) | (1L << T__0) | (1L << FORMATEXIT) | (1L << LITERALQUOTE) | (1L << ESCAPED) | (1L << UNCONDITIONAL) | (1L << CONDITIONAL) | (1L << REPEATABLE) | (1L << FIELD) | (1L << GLOBALVAR) | (1L << MODESWITCH) | (1L << MFNWITHLENGTH) | (1L << INCLUSION) | (1L << COMMANDC) | (1L << COMMANDX) | (1L << BANG) | (1L << BREAK) | (1L << COMMA) | (1L << DEBUG))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (ERROR - 66)) | (1L << (F - 66)) | (1L << (FATAL - 66)) | (1L << (HASH - 66)) | (1L << (IF - 66)) | (1L << (IOCC - 66)) | (1L << (LPAREN - 66)) | (1L << (MFN - 66)) | (1L << (NOCC - 66)) | (1L << (PERCENT - 66)) | (1L << (REF - 66)) | (1L << (S - 66)) | (1L << (SLASH - 66)) | (1L << (TRACE - 66)) | (1L << (TRIM - 66)) | (1L << (WARNING - 66)))) != 0)) {
				{
				{
				State = 30; statement();
				}
				}
				State = 35;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 36; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public GroupStatementContext groupStatement() {
			return GetRuleContext<GroupStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_statement);
		try {
			State = 40;
			switch (_input.La(1)) {
			case T__38:
			case T__37:
			case T__36:
			case T__35:
			case T__34:
			case T__33:
			case T__32:
			case T__30:
			case T__29:
			case T__28:
			case T__27:
			case T__26:
			case T__25:
			case T__24:
			case T__22:
			case T__21:
			case T__20:
			case T__19:
			case T__18:
			case T__17:
			case T__16:
			case T__15:
			case T__14:
			case T__13:
			case T__12:
			case T__11:
			case T__10:
			case T__9:
			case T__8:
			case T__7:
			case T__6:
			case T__5:
			case T__4:
			case T__3:
			case T__2:
			case T__1:
			case T__0:
			case FORMATEXIT:
			case LITERALQUOTE:
			case ESCAPED:
			case UNCONDITIONAL:
			case CONDITIONAL:
			case REPEATABLE:
			case FIELD:
			case GLOBALVAR:
			case MODESWITCH:
			case MFNWITHLENGTH:
			case INCLUSION:
			case COMMANDC:
			case COMMANDX:
			case BANG:
			case BREAK:
			case COMMA:
			case DEBUG:
			case ERROR:
			case F:
			case FATAL:
			case HASH:
			case IF:
			case IOCC:
			case MFN:
			case NOCC:
			case PERCENT:
			case REF:
			case S:
			case SLASH:
			case TRACE:
			case TRIM:
			case WARNING:
				EnterOuterAlt(_localctx, 1);
				{
				State = 38; nonGrouped();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 39; groupStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupStatementContext : ParserRuleContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public GroupStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterGroupStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitGroupStatement(this);
		}
	}

	[RuleVersion(0)]
	public GroupStatementContext groupStatement() {
		GroupStatementContext _localctx = new GroupStatementContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_groupStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 42; Match(LPAREN);
			State = 43; nonGrouped();
			State = 44; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonGroupedContext : ParserRuleContext {
		public FormatElementContext formatElement(int i) {
			return GetRuleContext<FormatElementContext>(i);
		}
		public FormatElementContext[] formatElement() {
			return GetRuleContexts<FormatElementContext>();
		}
		public NonGroupedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonGrouped; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNonGrouped(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNonGrouped(this);
		}
	}

	[RuleVersion(0)]
	public NonGroupedContext nonGrouped() {
		NonGroupedContext _localctx = new NonGroupedContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_nonGrouped);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 47;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 46; formatElement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 49;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,2,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormatElementContext : ParserRuleContext {
		public FormatElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_formatElement; } }
	 
		public FormatElementContext() { }
		public virtual void CopyFrom(FormatElementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MsgFunctionContext : FormatElementContext {
		public IToken index;
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public MsgFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMsgFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMsgFunction(this);
		}
	}
	public partial class BreakOperatorContext : FormatElementContext {
		public ITerminalNode BREAK() { return GetToken(PftParser.BREAK, 0); }
		public BreakOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterBreakOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitBreakOperator(this);
		}
	}
	public partial class MstNameFunctionContext : FormatElementContext {
		public MstNameFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMstNameFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMstNameFunction(this);
		}
	}
	public partial class ServerVersionFunctionContext : FormatElementContext {
		public ServerVersionFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterServerVersionFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitServerVersionFunction(this);
		}
	}
	public partial class ClientVersionFunctionContext : FormatElementContext {
		public ClientVersionFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterClientVersionFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitClientVersionFunction(this);
		}
	}
	public partial class SystemFunctionContext : FormatElementContext {
		public NonGroupedContext command;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public SystemFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSystemFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSystemFunction(this);
		}
	}
	public partial class PortFunctionContext : FormatElementContext {
		public PortFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPortFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPortFunction(this);
		}
	}
	public partial class NoccOperatorContext : FormatElementContext {
		public ITerminalNode NOCC() { return GetToken(PftParser.NOCC, 0); }
		public NoccOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNoccOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNoccOperator(this);
		}
	}
	public partial class CatFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public CatFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterCatFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitCatFunction(this);
		}
	}
	public partial class CommandXContext : FormatElementContext {
		public ITerminalNode COMMANDX() { return GetToken(PftParser.COMMANDX, 0); }
		public CommandXContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterCommandX(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitCommandX(this);
		}
	}
	public partial class IncludeFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public IncludeFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterIncludeFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitIncludeFunction(this);
		}
	}
	public partial class ErrorFunctionContext : FormatElementContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode ERROR() { return GetToken(PftParser.ERROR, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ErrorFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterErrorFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitErrorFunction(this);
		}
	}
	public partial class PadFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public IToken len;
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public PadFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPadFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPadFunction(this);
		}
	}
	public partial class UserFunctionContext : FormatElementContext {
		public UserFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterUserFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitUserFunction(this);
		}
	}
	public partial class TrimFunctionContext : FormatElementContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode TRIM() { return GetToken(PftParser.TRIM, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TrimFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTrimFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTrimFunction(this);
		}
	}
	public partial class RequireServerFunctionContext : FormatElementContext {
		public IToken version;
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RequireServerFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRequireServerFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRequireServerFunction(this);
		}
	}
	public partial class OrganizationFunctionContext : FormatElementContext {
		public OrganizationFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterOrganizationFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitOrganizationFunction(this);
		}
	}
	public partial class IoccOperatorContext : FormatElementContext {
		public ITerminalNode IOCC() { return GetToken(PftParser.IOCC, 0); }
		public IoccOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterIoccOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitIoccOperator(this);
		}
	}
	public partial class SFunctionContext : FormatElementContext {
		public ITerminalNode S() { return GetToken(PftParser.S, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public SFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSFunction(this);
		}
	}
	public partial class PutEnvFunctionContext : FormatElementContext {
		public IToken name;
		public NonGroupedContext theValue;
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public PutEnvFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPutEnvFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPutEnvFunction(this);
		}
	}
	public partial class DebugFunctionContext : FormatElementContext {
		public ITerminalNode DEBUG() { return GetToken(PftParser.DEBUG, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public DebugFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterDebugFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitDebugFunction(this);
		}
	}
	public partial class SlashOperatorContext : FormatElementContext {
		public ITerminalNode SLASH() { return GetToken(PftParser.SLASH, 0); }
		public SlashOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSlashOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSlashOperator(this);
		}
	}
	public partial class PadLeftFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public IToken len;
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public PadLeftFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPadLeftFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPadLeftFunction(this);
		}
	}
	public partial class AskFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public AskFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterAskFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitAskFunction(this);
		}
	}
	public partial class ReplaceFunctionContext : FormatElementContext {
		public FormatElementContext arg1;
		public FormatElementContext arg2;
		public FormatElementContext arg3;
		public FormatElementContext formatElement(int i) {
			return GetRuleContext<FormatElementContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PftParser.COMMA); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public FormatElementContext[] formatElement() {
			return GetRuleContexts<FormatElementContext>();
		}
		public ITerminalNode COMMA(int i) {
			return GetToken(PftParser.COMMA, i);
		}
		public ReplaceFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterReplaceFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitReplaceFunction(this);
		}
	}
	public partial class LeftFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public IToken len;
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public LeftFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterLeftFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitLeftFunction(this);
		}
	}
	public partial class PercentOperatorContext : FormatElementContext {
		public ITerminalNode PERCENT() { return GetToken(PftParser.PERCENT, 0); }
		public PercentOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPercentOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPercentOperator(this);
		}
	}
	public partial class TrimRightFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TrimRightFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTrimRightFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTrimRightFunction(this);
		}
	}
	public partial class MidFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public IToken offset;
		public IToken len;
		public ITerminalNode[] COMMA() { return GetTokens(PftParser.COMMA); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode UNSIGNED(int i) {
			return GetToken(PftParser.UNSIGNED, i);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode[] UNSIGNED() { return GetTokens(PftParser.UNSIGNED); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PftParser.COMMA, i);
		}
		public MidFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMidFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMidFunction(this);
		}
	}
	public partial class RightFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public IToken len;
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public RightFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRightFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRightFunction(this);
		}
	}
	public partial class NoccFieldContext : FormatElementContext {
		public ITerminalNode NOCC() { return GetToken(PftParser.NOCC, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode FIELD() { return GetToken(PftParser.FIELD, 0); }
		public NoccFieldContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNoccField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNoccField(this);
		}
	}
	public partial class FormatExitContext : FormatElementContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode FORMATEXIT() { return GetToken(PftParser.FORMATEXIT, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public FormatExitContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFormatExit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFormatExit(this);
		}
	}
	public partial class TypeFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TypeFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTypeFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTypeFunction(this);
		}
	}
	public partial class TraceFunctionContext : FormatElementContext {
		public ITerminalNode TRACE() { return GetToken(PftParser.TRACE, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TraceFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTraceFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTraceFunction(this);
		}
	}
	public partial class ToLowerFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ToLowerFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterToLowerFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitToLowerFunction(this);
		}
	}
	public partial class PadRightFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public IToken len;
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public PadRightFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterPadRightFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitPadRightFunction(this);
		}
	}
	public partial class FieldReferenceContext : FormatElementContext {
		public RigthHandContext rigthHand() {
			return GetRuleContext<RigthHandContext>(0);
		}
		public LeftHandContext leftHand() {
			return GetRuleContext<LeftHandContext>(0);
		}
		public ITerminalNode FIELD() { return GetToken(PftParser.FIELD, 0); }
		public FieldReferenceContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFieldReference(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFieldReference(this);
		}
	}
	public partial class SimpleDateContext : FormatElementContext {
		public SimpleDateContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSimpleDate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSimpleDate(this);
		}
	}
	public partial class HashOperatorContext : FormatElementContext {
		public ITerminalNode HASH() { return GetToken(PftParser.HASH, 0); }
		public HashOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterHashOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitHashOperator(this);
		}
	}
	public partial class ModeSwitchContext : FormatElementContext {
		public ITerminalNode MODESWITCH() { return GetToken(PftParser.MODESWITCH, 0); }
		public ModeSwitchContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterModeSwitch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitModeSwitch(this);
		}
	}
	public partial class CommaOperatorContext : FormatElementContext {
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public CommaOperatorContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterCommaOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitCommaOperator(this);
		}
	}
	public partial class HostFunctionContext : FormatElementContext {
		public HostFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterHostFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitHostFunction(this);
		}
	}
	public partial class ChrFunctionContext : FormatElementContext {
		public IToken code;
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode UNSIGNED() { return GetToken(PftParser.UNSIGNED, 0); }
		public ChrFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterChrFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitChrFunction(this);
		}
	}
	public partial class FormattedTimeContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public FormattedTimeContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFormattedTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFormattedTime(this);
		}
	}
	public partial class RefFunctionContext : FormatElementContext {
		public ArithExprContext arg1;
		public NonGroupedContext arg2;
		public ITerminalNode REF() { return GetToken(PftParser.REF, 0); }
		public ITerminalNode COMMA() { return GetToken(PftParser.COMMA, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ArithExprContext arithExpr() {
			return GetRuleContext<ArithExprContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RefFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRefFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRefFunction(this);
		}
	}
	public partial class GetEnvFunctionContext : FormatElementContext {
		public IToken name;
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public GetEnvFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterGetEnvFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitGetEnvFunction(this);
		}
	}
	public partial class NowFunctionContext : FormatElementContext {
		public NowFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNowFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNowFunction(this);
		}
	}
	public partial class UnconditionalLiteralContext : FormatElementContext {
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public UnconditionalLiteralContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterUnconditionalLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitUnconditionalLiteral(this);
		}
	}
	public partial class MfnWithLengthContext : FormatElementContext {
		public ITerminalNode MFNWITHLENGTH() { return GetToken(PftParser.MFNWITHLENGTH, 0); }
		public MfnWithLengthContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMfnWithLength(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMfnWithLength(this);
		}
	}
	public partial class OrdFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public OrdFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterOrdFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitOrdFunction(this);
		}
	}
	public partial class FatalFunctionContext : FormatElementContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode FATAL() { return GetToken(PftParser.FATAL, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public FatalFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFatalFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFatalFunction(this);
		}
	}
	public partial class RequireClientFunctionContext : FormatElementContext {
		public IToken version;
		public ITerminalNode UNCONDITIONAL() { return GetToken(PftParser.UNCONDITIONAL, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RequireClientFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRequireClientFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRequireClientFunction(this);
		}
	}
	public partial class IncludeStatementContext : FormatElementContext {
		public ITerminalNode INCLUSION() { return GetToken(PftParser.INCLUSION, 0); }
		public IncludeStatementContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterIncludeStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitIncludeStatement(this);
		}
	}
	public partial class ToUpperFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ToUpperFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterToUpperFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitToUpperFunction(this);
		}
	}
	public partial class SimpleMfnContext : FormatElementContext {
		public ITerminalNode MFN() { return GetToken(PftParser.MFN, 0); }
		public SimpleMfnContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSimpleMfn(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSimpleMfn(this);
		}
	}
	public partial class FormattedDateContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public FormattedDateContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFormattedDate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFormattedDate(this);
		}
	}
	public partial class ConditionalStatementOuterContext : FormatElementContext {
		public ConditionalStatementContext conditionalStatement() {
			return GetRuleContext<ConditionalStatementContext>(0);
		}
		public ConditionalStatementOuterContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionalStatementOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionalStatementOuter(this);
		}
	}
	public partial class SimpleTimeContext : FormatElementContext {
		public SimpleTimeContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSimpleTime(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSimpleTime(this);
		}
	}
	public partial class GlobalReferenceContext : FormatElementContext {
		public ITerminalNode GLOBALVAR() { return GetToken(PftParser.GLOBALVAR, 0); }
		public GlobalReferenceContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterGlobalReference(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitGlobalReference(this);
		}
	}
	public partial class TrimLeftFunctionContext : FormatElementContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public TrimLeftFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterTrimLeftFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitTrimLeftFunction(this);
		}
	}
	public partial class WarningFunctionContext : FormatElementContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode WARNING() { return GetToken(PftParser.WARNING, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public WarningFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterWarningFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitWarningFunction(this);
		}
	}
	public partial class CommandCContext : FormatElementContext {
		public ITerminalNode COMMANDC() { return GetToken(PftParser.COMMANDC, 0); }
		public CommandCContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterCommandC(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitCommandC(this);
		}
	}
	public partial class EscapedLiteralContext : FormatElementContext {
		public ITerminalNode ESCAPED() { return GetToken(PftParser.ESCAPED, 0); }
		public EscapedLiteralContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterEscapedLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitEscapedLiteral(this);
		}
	}
	public partial class FFunctionContext : FormatElementContext {
		public ArithExprContext arg1;
		public ArithExprContext arg2;
		public ArithExprContext arg3;
		public ITerminalNode F() { return GetToken(PftParser.F, 0); }
		public ArithExprContext arithExpr(int i) {
			return GetRuleContext<ArithExprContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PftParser.COMMA); }
		public ArithExprContext[] arithExpr() {
			return GetRuleContexts<ArithExprContext>();
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PftParser.COMMA, i);
		}
		public FFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFFunction(this);
		}
	}
	public partial class LiteralQuoteContext : FormatElementContext {
		public ITerminalNode LITERALQUOTE() { return GetToken(PftParser.LITERALQUOTE, 0); }
		public LiteralQuoteContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterLiteralQuote(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitLiteralQuote(this);
		}
	}
	public partial class DatabaseFunctionContext : FormatElementContext {
		public DatabaseFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterDatabaseFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitDatabaseFunction(this);
		}
	}
	public partial class BeepFunctionContext : FormatElementContext {
		public BeepFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterBeepFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitBeepFunction(this);
		}
	}
	public partial class MessageFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public MessageFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMessageFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMessageFunction(this);
		}
	}
	public partial class ProcFunctionContext : FormatElementContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ProcFunctionContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterProcFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitProcFunction(this);
		}
	}
	public partial class DebugBreakContext : FormatElementContext {
		public ITerminalNode BANG() { return GetToken(PftParser.BANG, 0); }
		public DebugBreakContext(FormatElementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterDebugBreak(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitDebugBreak(this);
		}
	}

	[RuleVersion(0)]
	public FormatElementContext formatElement() {
		FormatElementContext _localctx = new FormatElementContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_formatElement);
		int _la;
		try {
			State = 300;
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				_localctx = new ConditionalStatementOuterContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 51; conditionalStatement();
				}
				break;

			case 2:
				_localctx = new FieldReferenceContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 52; leftHand();
				State = 53; Match(FIELD);
				State = 54; rigthHand();
				}
				break;

			case 3:
				_localctx = new FormatExitContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 56; Match(FORMATEXIT);
				State = 57; Match(LPAREN);
				State = 58; nonGrouped();
				State = 59; Match(RPAREN);
				}
				break;

			case 4:
				_localctx = new ErrorFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 61; Match(ERROR);
				State = 62; Match(LPAREN);
				State = 63; nonGrouped();
				State = 64; Match(RPAREN);
				}
				break;

			case 5:
				_localctx = new WarningFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 66; Match(WARNING);
				State = 67; Match(LPAREN);
				State = 68; nonGrouped();
				State = 69; Match(RPAREN);
				}
				break;

			case 6:
				_localctx = new FatalFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 71; Match(FATAL);
				State = 72; Match(LPAREN);
				State = 73; nonGrouped();
				State = 74; Match(RPAREN);
				}
				break;

			case 7:
				_localctx = new TraceFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 76; Match(TRACE);
				State = 77; Match(LPAREN);
				State = 78; nonGrouped();
				State = 79; Match(RPAREN);
				}
				break;

			case 8:
				_localctx = new DebugFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 81; Match(DEBUG);
				State = 82; Match(LPAREN);
				State = 83; nonGrouped();
				State = 84; Match(RPAREN);
				}
				break;

			case 9:
				_localctx = new DebugBreakContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 86; Match(BANG);
				}
				break;

			case 10:
				_localctx = new SFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 87; Match(S);
				State = 88; Match(LPAREN);
				State = 89; nonGrouped();
				State = 90; Match(RPAREN);
				}
				break;

			case 11:
				_localctx = new FFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 92; Match(F);
				State = 93; Match(LPAREN);
				State = 94; ((FFunctionContext)_localctx).arg1 = arithExpr(0);
				State = 101;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 95; Match(COMMA);
					State = 96; ((FFunctionContext)_localctx).arg2 = arithExpr(0);
					State = 99;
					_la = _input.La(1);
					if (_la==COMMA) {
						{
						State = 97; Match(COMMA);
						State = 98; ((FFunctionContext)_localctx).arg3 = arithExpr(0);
						}
					}

					}
				}

				State = 103; Match(RPAREN);
				}
				break;

			case 12:
				_localctx = new RefFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 105; Match(REF);
				State = 106; Match(LPAREN);
				State = 107; ((RefFunctionContext)_localctx).arg1 = arithExpr(0);
				State = 108; Match(COMMA);
				State = 109; ((RefFunctionContext)_localctx).arg2 = nonGrouped();
				State = 110; Match(RPAREN);
				}
				break;

			case 13:
				_localctx = new TrimFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 112; Match(TRIM);
				State = 113; Match(LPAREN);
				State = 114; nonGrouped();
				State = 115; Match(RPAREN);
				}
				break;

			case 14:
				_localctx = new IoccOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 117; Match(IOCC);
				}
				break;

			case 15:
				_localctx = new NoccOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 118; Match(NOCC);
				}
				break;

			case 16:
				_localctx = new NoccFieldContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 119; Match(NOCC);
				State = 120; Match(LPAREN);
				State = 121; Match(FIELD);
				State = 122; Match(RPAREN);
				}
				break;

			case 17:
				_localctx = new LiteralQuoteContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 123; Match(LITERALQUOTE);
				}
				break;

			case 18:
				_localctx = new EscapedLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 124; Match(ESCAPED);
				}
				break;

			case 19:
				_localctx = new BreakOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 125; Match(BREAK);
				}
				break;

			case 20:
				_localctx = new GlobalReferenceContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 126; Match(GLOBALVAR);
				}
				break;

			case 21:
				_localctx = new UnconditionalLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 21);
				{
				State = 127; Match(UNCONDITIONAL);
				}
				break;

			case 22:
				_localctx = new SimpleMfnContext(_localctx);
				EnterOuterAlt(_localctx, 22);
				{
				State = 128; Match(MFN);
				}
				break;

			case 23:
				_localctx = new MfnWithLengthContext(_localctx);
				EnterOuterAlt(_localctx, 23);
				{
				State = 129; Match(MFNWITHLENGTH);
				}
				break;

			case 24:
				_localctx = new CommaOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 24);
				{
				State = 130; Match(COMMA);
				}
				break;

			case 25:
				_localctx = new SlashOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 25);
				{
				State = 131; Match(SLASH);
				}
				break;

			case 26:
				_localctx = new HashOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 26);
				{
				State = 132; Match(HASH);
				}
				break;

			case 27:
				_localctx = new PercentOperatorContext(_localctx);
				EnterOuterAlt(_localctx, 27);
				{
				State = 133; Match(PERCENT);
				}
				break;

			case 28:
				_localctx = new ModeSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 28);
				{
				State = 134; Match(MODESWITCH);
				}
				break;

			case 29:
				_localctx = new CommandCContext(_localctx);
				EnterOuterAlt(_localctx, 29);
				{
				State = 135; Match(COMMANDC);
				}
				break;

			case 30:
				_localctx = new CommandXContext(_localctx);
				EnterOuterAlt(_localctx, 30);
				{
				State = 136; Match(COMMANDX);
				}
				break;

			case 31:
				_localctx = new GetEnvFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 31);
				{
				State = 137; Match(T__24);
				State = 138; Match(LPAREN);
				State = 139; ((GetEnvFunctionContext)_localctx).name = Match(UNCONDITIONAL);
				State = 140; Match(RPAREN);
				}
				break;

			case 32:
				_localctx = new PutEnvFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 32);
				{
				State = 141; Match(T__2);
				State = 142; Match(LPAREN);
				State = 143; ((PutEnvFunctionContext)_localctx).name = Match(UNCONDITIONAL);
				State = 144; Match(COMMA);
				State = 145; ((PutEnvFunctionContext)_localctx).theValue = nonGrouped();
				State = 146; Match(RPAREN);
				}
				break;

			case 33:
				_localctx = new SystemFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 33);
				{
				State = 148; Match(T__29);
				State = 149; Match(LPAREN);
				State = 150; ((SystemFunctionContext)_localctx).command = nonGrouped();
				State = 151; Match(RPAREN);
				}
				break;

			case 34:
				_localctx = new HostFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 34);
				{
				State = 153; Match(T__20);
				}
				break;

			case 35:
				_localctx = new PortFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 35);
				{
				State = 154; Match(T__19);
				}
				break;

			case 36:
				_localctx = new ServerVersionFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 36);
				{
				State = 155; Match(T__9);
				}
				break;

			case 37:
				_localctx = new ClientVersionFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 37);
				{
				State = 156; Match(T__36);
				}
				break;

			case 38:
				_localctx = new OrganizationFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 38);
				{
				State = 157; Match(T__1);
				}
				break;

			case 39:
				_localctx = new MstNameFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 39);
				{
				State = 158; Match(T__18);
				}
				break;

			case 40:
				_localctx = new DatabaseFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 40);
				{
				State = 159; Match(T__15);
				}
				break;

			case 41:
				_localctx = new UserFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 41);
				{
				State = 160; Match(T__11);
				}
				break;

			case 42:
				_localctx = new RequireServerFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 42);
				{
				State = 161; Match(T__3);
				State = 162; Match(LPAREN);
				State = 163; ((RequireServerFunctionContext)_localctx).version = Match(UNCONDITIONAL);
				State = 164; Match(RPAREN);
				}
				break;

			case 43:
				_localctx = new RequireClientFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 43);
				{
				State = 165; Match(T__27);
				State = 166; Match(LPAREN);
				State = 167; ((RequireClientFunctionContext)_localctx).version = Match(UNCONDITIONAL);
				State = 168; Match(RPAREN);
				}
				break;

			case 44:
				_localctx = new LeftFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 44);
				{
				State = 169; Match(T__37);
				State = 170; Match(LPAREN);
				State = 171; ((LeftFunctionContext)_localctx).text = nonGrouped();
				State = 172; Match(COMMA);
				State = 173; ((LeftFunctionContext)_localctx).len = Match(UNSIGNED);
				State = 174; Match(RPAREN);
				}
				break;

			case 45:
				_localctx = new MidFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 45);
				{
				State = 176; Match(T__28);
				State = 177; Match(LPAREN);
				State = 178; ((MidFunctionContext)_localctx).text = nonGrouped();
				State = 179; Match(COMMA);
				State = 180; ((MidFunctionContext)_localctx).offset = Match(UNSIGNED);
				State = 181; Match(COMMA);
				State = 182; ((MidFunctionContext)_localctx).len = Match(UNSIGNED);
				State = 183; Match(RPAREN);
				}
				break;

			case 46:
				_localctx = new RightFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 46);
				{
				State = 185; Match(T__4);
				State = 186; Match(LPAREN);
				State = 187; ((RightFunctionContext)_localctx).text = nonGrouped();
				State = 188; Match(COMMA);
				State = 189; ((RightFunctionContext)_localctx).len = Match(UNSIGNED);
				State = 190; Match(RPAREN);
				}
				break;

			case 47:
				_localctx = new TrimLeftFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 47);
				{
				State = 192; Match(T__12);
				State = 193; Match(LPAREN);
				State = 194; nonGrouped();
				State = 195; Match(RPAREN);
				}
				break;

			case 48:
				_localctx = new TrimRightFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 48);
				{
				State = 197; Match(T__25);
				State = 198; Match(LPAREN);
				State = 199; ((TrimRightFunctionContext)_localctx).text = nonGrouped();
				State = 200; Match(RPAREN);
				}
				break;

			case 49:
				_localctx = new PadFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 49);
				{
				State = 202; Match(T__32);
				State = 203; Match(LPAREN);
				State = 204; ((PadFunctionContext)_localctx).text = nonGrouped();
				State = 205; Match(COMMA);
				State = 206; ((PadFunctionContext)_localctx).len = Match(UNSIGNED);
				State = 207; Match(RPAREN);
				}
				break;

			case 50:
				_localctx = new PadLeftFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 50);
				{
				State = 209; Match(T__6);
				State = 210; Match(LPAREN);
				State = 211; ((PadLeftFunctionContext)_localctx).text = nonGrouped();
				State = 212; Match(COMMA);
				State = 213; ((PadLeftFunctionContext)_localctx).len = Match(UNSIGNED);
				State = 214; Match(RPAREN);
				}
				break;

			case 51:
				_localctx = new PadRightFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 51);
				{
				State = 216; Match(T__30);
				State = 217; Match(LPAREN);
				State = 218; ((PadRightFunctionContext)_localctx).text = nonGrouped();
				State = 219; Match(COMMA);
				State = 220; ((PadRightFunctionContext)_localctx).len = Match(UNSIGNED);
				State = 221; Match(RPAREN);
				}
				break;

			case 52:
				_localctx = new MsgFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 52);
				{
				State = 223; Match(T__35);
				State = 224; Match(LPAREN);
				State = 225; ((MsgFunctionContext)_localctx).index = Match(UNSIGNED);
				State = 226; Match(RPAREN);
				}
				break;

			case 53:
				_localctx = new ChrFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 53);
				{
				State = 227; Match(T__33);
				State = 228; Match(LPAREN);
				State = 229; ((ChrFunctionContext)_localctx).code = Match(UNSIGNED);
				State = 230; Match(RPAREN);
				}
				break;

			case 54:
				_localctx = new OrdFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 54);
				{
				State = 231; Match(T__0);
				State = 232; Match(LPAREN);
				State = 233; ((OrdFunctionContext)_localctx).text = nonGrouped();
				State = 234; Match(RPAREN);
				}
				break;

			case 55:
				_localctx = new ToLowerFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 55);
				{
				State = 236; Match(T__26);
				State = 237; Match(LPAREN);
				State = 238; ((ToLowerFunctionContext)_localctx).text = nonGrouped();
				State = 239; Match(RPAREN);
				}
				break;

			case 56:
				_localctx = new ToUpperFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 56);
				{
				State = 241; Match(T__17);
				State = 242; Match(LPAREN);
				State = 243; ((ToUpperFunctionContext)_localctx).text = nonGrouped();
				State = 244; Match(RPAREN);
				}
				break;

			case 57:
				_localctx = new ReplaceFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 57);
				{
				State = 246; Match(T__13);
				State = 247; Match(LPAREN);
				State = 248; ((ReplaceFunctionContext)_localctx).arg1 = formatElement();
				State = 249; Match(COMMA);
				State = 250; ((ReplaceFunctionContext)_localctx).arg2 = formatElement();
				State = 251; Match(COMMA);
				State = 252; ((ReplaceFunctionContext)_localctx).arg3 = formatElement();
				State = 253; Match(RPAREN);
				}
				break;

			case 58:
				_localctx = new TypeFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 58);
				{
				State = 255; Match(T__7);
				State = 256; Match(LPAREN);
				State = 257; ((TypeFunctionContext)_localctx).text = nonGrouped();
				State = 258; Match(RPAREN);
				}
				break;

			case 59:
				_localctx = new IncludeFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 59);
				{
				State = 260; Match(T__10);
				State = 261; Match(LPAREN);
				State = 262; ((IncludeFunctionContext)_localctx).text = nonGrouped();
				State = 263; Match(RPAREN);
				}
				break;

			case 60:
				_localctx = new IncludeStatementContext(_localctx);
				EnterOuterAlt(_localctx, 60);
				{
				State = 265; Match(INCLUSION);
				}
				break;

			case 61:
				_localctx = new CatFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 61);
				{
				State = 266; Match(T__21);
				State = 267; Match(LPAREN);
				State = 268; ((CatFunctionContext)_localctx).text = nonGrouped();
				State = 269; Match(RPAREN);
				}
				break;

			case 62:
				_localctx = new SimpleDateContext(_localctx);
				EnterOuterAlt(_localctx, 62);
				{
				State = 271; Match(T__16);
				}
				break;

			case 63:
				_localctx = new FormattedDateContext(_localctx);
				EnterOuterAlt(_localctx, 63);
				{
				State = 272; Match(T__16);
				State = 273; Match(LPAREN);
				State = 274; ((FormattedDateContext)_localctx).text = nonGrouped();
				State = 275; Match(RPAREN);
				}
				break;

			case 64:
				_localctx = new NowFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 64);
				{
				State = 277; Match(T__14);
				}
				break;

			case 65:
				_localctx = new SimpleTimeContext(_localctx);
				EnterOuterAlt(_localctx, 65);
				{
				State = 278; Match(T__5);
				}
				break;

			case 66:
				_localctx = new FormattedTimeContext(_localctx);
				EnterOuterAlt(_localctx, 66);
				{
				State = 279; Match(T__5);
				State = 280; Match(LPAREN);
				State = 281; ((FormattedTimeContext)_localctx).text = nonGrouped();
				State = 282; Match(RPAREN);
				}
				break;

			case 67:
				_localctx = new ProcFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 67);
				{
				State = 284; Match(T__8);
				State = 285; Match(LPAREN);
				State = 286; ((ProcFunctionContext)_localctx).text = nonGrouped();
				State = 287; Match(RPAREN);
				}
				break;

			case 68:
				_localctx = new MessageFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 68);
				{
				State = 289; Match(T__22);
				State = 290; Match(LPAREN);
				State = 291; ((MessageFunctionContext)_localctx).text = nonGrouped();
				State = 292; Match(RPAREN);
				}
				break;

			case 69:
				_localctx = new AskFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 69);
				{
				State = 294; Match(T__34);
				State = 295; Match(LPAREN);
				State = 296; ((AskFunctionContext)_localctx).text = nonGrouped();
				State = 297; Match(RPAREN);
				}
				break;

			case 70:
				_localctx = new BeepFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 70);
				{
				State = 299; Match(T__38);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeftHandContext : ParserRuleContext {
		public ITerminalNode[] REPEATABLE() { return GetTokens(PftParser.REPEATABLE); }
		public ITerminalNode CONDITIONAL(int i) {
			return GetToken(PftParser.CONDITIONAL, i);
		}
		public ITerminalNode[] CONDITIONAL() { return GetTokens(PftParser.CONDITIONAL); }
		public ITerminalNode REPEATABLE(int i) {
			return GetToken(PftParser.REPEATABLE, i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(PftParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(PftParser.PLUS, i);
		}
		public LeftHandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_leftHand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterLeftHand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitLeftHand(this);
		}
	}

	[RuleVersion(0)]
	public LeftHandContext leftHand() {
		LeftHandContext _localctx = new LeftHandContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_leftHand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 309;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==CONDITIONAL || _la==REPEATABLE) {
				{
				State = 307;
				switch (_input.La(1)) {
				case REPEATABLE:
					{
					State = 302; Match(REPEATABLE);
					State = 304;
					_la = _input.La(1);
					if (_la==PLUS) {
						{
						State = 303; Match(PLUS);
						}
					}

					}
					break;
				case CONDITIONAL:
					{
					State = 306; Match(CONDITIONAL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 311;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RigthHandContext : ParserRuleContext {
		public ITerminalNode[] REPEATABLE() { return GetTokens(PftParser.REPEATABLE); }
		public ITerminalNode CONDITIONAL(int i) {
			return GetToken(PftParser.CONDITIONAL, i);
		}
		public ITerminalNode[] CONDITIONAL() { return GetTokens(PftParser.CONDITIONAL); }
		public ITerminalNode REPEATABLE(int i) {
			return GetToken(PftParser.REPEATABLE, i);
		}
		public ITerminalNode[] PLUS() { return GetTokens(PftParser.PLUS); }
		public ITerminalNode PLUS(int i) {
			return GetToken(PftParser.PLUS, i);
		}
		public RigthHandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rigthHand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRigthHand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRigthHand(this);
		}
	}

	[RuleVersion(0)]
	public RigthHandContext rigthHand() {
		RigthHandContext _localctx = new RigthHandContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_rigthHand);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 319;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,11,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					State = 317;
					switch (_input.La(1)) {
					case REPEATABLE:
					case PLUS:
						{
						State = 313;
						_la = _input.La(1);
						if (_la==PLUS) {
							{
							State = 312; Match(PLUS);
							}
						}

						State = 315; Match(REPEATABLE);
						}
						break;
					case CONDITIONAL:
						{
						State = 316; Match(CONDITIONAL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 321;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,11,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalStatementContext : ParserRuleContext {
		public StatementContext thenBranch;
		public StatementContext elseBranch;
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public ITerminalNode THEN() { return GetToken(PftParser.THEN, 0); }
		public ITerminalNode IF() { return GetToken(PftParser.IF, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode FI() { return GetToken(PftParser.FI, 0); }
		public ITerminalNode ELSE() { return GetToken(PftParser.ELSE, 0); }
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ConditionalStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionalStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionalStatement(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalStatementContext conditionalStatement() {
		ConditionalStatementContext _localctx = new ConditionalStatementContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_conditionalStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 322; Match(IF);
			State = 323; condition(0);
			State = 324; Match(THEN);
			State = 328;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__38) | (1L << T__37) | (1L << T__36) | (1L << T__35) | (1L << T__34) | (1L << T__33) | (1L << T__32) | (1L << T__30) | (1L << T__29) | (1L << T__28) | (1L << T__27) | (1L << T__26) | (1L << T__25) | (1L << T__24) | (1L << T__22) | (1L << T__21) | (1L << T__20) | (1L << T__19) | (1L << T__18) | (1L << T__17) | (1L << T__16) | (1L << T__15) | (1L << T__14) | (1L << T__13) | (1L << T__12) | (1L << T__11) | (1L << T__10) | (1L << T__9) | (1L << T__8) | (1L << T__7) | (1L << T__6) | (1L << T__5) | (1L << T__4) | (1L << T__3) | (1L << T__2) | (1L << T__1) | (1L << T__0) | (1L << FORMATEXIT) | (1L << LITERALQUOTE) | (1L << ESCAPED) | (1L << UNCONDITIONAL) | (1L << CONDITIONAL) | (1L << REPEATABLE) | (1L << FIELD) | (1L << GLOBALVAR) | (1L << MODESWITCH) | (1L << MFNWITHLENGTH) | (1L << INCLUSION) | (1L << COMMANDC) | (1L << COMMANDX) | (1L << BANG) | (1L << BREAK) | (1L << COMMA) | (1L << DEBUG))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (ERROR - 66)) | (1L << (F - 66)) | (1L << (FATAL - 66)) | (1L << (HASH - 66)) | (1L << (IF - 66)) | (1L << (IOCC - 66)) | (1L << (LPAREN - 66)) | (1L << (MFN - 66)) | (1L << (NOCC - 66)) | (1L << (PERCENT - 66)) | (1L << (REF - 66)) | (1L << (S - 66)) | (1L << (SLASH - 66)) | (1L << (TRACE - 66)) | (1L << (TRIM - 66)) | (1L << (WARNING - 66)))) != 0)) {
				{
				{
				State = 325; _localctx.thenBranch = statement();
				}
				}
				State = 330;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 338;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 331; Match(ELSE);
				State = 335;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__38) | (1L << T__37) | (1L << T__36) | (1L << T__35) | (1L << T__34) | (1L << T__33) | (1L << T__32) | (1L << T__30) | (1L << T__29) | (1L << T__28) | (1L << T__27) | (1L << T__26) | (1L << T__25) | (1L << T__24) | (1L << T__22) | (1L << T__21) | (1L << T__20) | (1L << T__19) | (1L << T__18) | (1L << T__17) | (1L << T__16) | (1L << T__15) | (1L << T__14) | (1L << T__13) | (1L << T__12) | (1L << T__11) | (1L << T__10) | (1L << T__9) | (1L << T__8) | (1L << T__7) | (1L << T__6) | (1L << T__5) | (1L << T__4) | (1L << T__3) | (1L << T__2) | (1L << T__1) | (1L << T__0) | (1L << FORMATEXIT) | (1L << LITERALQUOTE) | (1L << ESCAPED) | (1L << UNCONDITIONAL) | (1L << CONDITIONAL) | (1L << REPEATABLE) | (1L << FIELD) | (1L << GLOBALVAR) | (1L << MODESWITCH) | (1L << MFNWITHLENGTH) | (1L << INCLUSION) | (1L << COMMANDC) | (1L << COMMANDX) | (1L << BANG) | (1L << BREAK) | (1L << COMMA) | (1L << DEBUG))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (ERROR - 66)) | (1L << (F - 66)) | (1L << (FATAL - 66)) | (1L << (HASH - 66)) | (1L << (IF - 66)) | (1L << (IOCC - 66)) | (1L << (LPAREN - 66)) | (1L << (MFN - 66)) | (1L << (NOCC - 66)) | (1L << (PERCENT - 66)) | (1L << (REF - 66)) | (1L << (S - 66)) | (1L << (SLASH - 66)) | (1L << (TRACE - 66)) | (1L << (TRIM - 66)) | (1L << (WARNING - 66)))) != 0)) {
					{
					{
					State = 332; _localctx.elseBranch = statement();
					}
					}
					State = 337;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 340; Match(FI);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
	 
		public ConditionContext() { }
		public virtual void CopyFrom(ConditionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConditionArithContext : ConditionContext {
		public ArithConditionContext arithCondition() {
			return GetRuleContext<ArithConditionContext>(0);
		}
		public ConditionArithContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionArith(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionArith(this);
		}
	}
	public partial class ConditionParenContext : ConditionContext {
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ConditionParenContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionParen(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionParen(this);
		}
	}
	public partial class ConditionStringContext : ConditionContext {
		public StringTestContext stringTest() {
			return GetRuleContext<StringTestContext>(0);
		}
		public ConditionStringContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionString(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionString(this);
		}
	}
	public partial class ConditionFieldContext : ConditionContext {
		public FieldPresenseContext fieldPresense() {
			return GetRuleContext<FieldPresenseContext>(0);
		}
		public ConditionFieldContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionField(this);
		}
	}
	public partial class ConditionNotContext : ConditionContext {
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PftParser.NOT, 0); }
		public ConditionNotContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionNot(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionNot(this);
		}
	}
	public partial class ConditionAndOrContext : ConditionContext {
		public IToken op;
		public ConditionContext[] condition() {
			return GetRuleContexts<ConditionContext>();
		}
		public ITerminalNode AND() { return GetToken(PftParser.AND, 0); }
		public ConditionContext condition(int i) {
			return GetRuleContext<ConditionContext>(i);
		}
		public ITerminalNode OR() { return GetToken(PftParser.OR, 0); }
		public ConditionAndOrContext(ConditionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterConditionAndOr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitConditionAndOr(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		return condition(0);
	}

	private ConditionContext condition(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ConditionContext _localctx = new ConditionContext(_ctx, _parentState);
		ConditionContext _prevctx = _localctx;
		int _startState = 16;
		EnterRecursionRule(_localctx, 16, RULE_condition, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 352;
			switch ( Interpreter.AdaptivePredict(_input,15,_ctx) ) {
			case 1:
				{
				_localctx = new ConditionNotContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 343; Match(NOT);
				State = 344; condition(5);
				}
				break;

			case 2:
				{
				_localctx = new ConditionParenContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 345; Match(LPAREN);
				State = 346; condition(0);
				State = 347; Match(RPAREN);
				}
				break;

			case 3:
				{
				_localctx = new ConditionStringContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 349; stringTest();
				}
				break;

			case 4:
				{
				_localctx = new ConditionFieldContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 350; fieldPresense();
				}
				break;

			case 5:
				{
				_localctx = new ConditionArithContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 351; arithCondition();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 359;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,16,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new ConditionAndOrContext(new ConditionContext(_parentctx, _parentState));
					PushNewRecursionContext(_localctx, _startState, RULE_condition);
					State = 354;
					if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
					State = 355;
					((ConditionAndOrContext)_localctx).op = _input.Lt(1);
					_la = _input.La(1);
					if ( !(_la==AND || _la==OR) ) {
						((ConditionAndOrContext)_localctx).op = _errHandler.RecoverInline(this);
					}
					Consume();
					State = 356; condition(7);
					}
					} 
				}
				State = 361;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,16,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StringTestContext : ParserRuleContext {
		public FormatElementContext left;
		public IToken op;
		public FormatElementContext right;
		public ITerminalNode MORE() { return GetToken(PftParser.MORE, 0); }
		public ITerminalNode LESSEQ() { return GetToken(PftParser.LESSEQ, 0); }
		public ITerminalNode EQUALS() { return GetToken(PftParser.EQUALS, 0); }
		public ITerminalNode LESS() { return GetToken(PftParser.LESS, 0); }
		public FormatElementContext formatElement(int i) {
			return GetRuleContext<FormatElementContext>(i);
		}
		public ITerminalNode MOREEQ() { return GetToken(PftParser.MOREEQ, 0); }
		public ITerminalNode NOTEQUALS() { return GetToken(PftParser.NOTEQUALS, 0); }
		public ITerminalNode COLON() { return GetToken(PftParser.COLON, 0); }
		public FormatElementContext[] formatElement() {
			return GetRuleContexts<FormatElementContext>();
		}
		public StringTestContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringTest; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterStringTest(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitStringTest(this);
		}
	}

	[RuleVersion(0)]
	public StringTestContext stringTest() {
		StringTestContext _localctx = new StringTestContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_stringTest);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 362; _localctx.left = formatElement();
			State = 363;
			_localctx.op = _input.Lt(1);
			_la = _input.La(1);
			if ( !(((((_la - 61)) & ~0x3f) == 0 && ((1L << (_la - 61)) & ((1L << (COLON - 61)) | (1L << (EQUALS - 61)) | (1L << (LESS - 61)) | (1L << (LESSEQ - 61)) | (1L << (MORE - 61)) | (1L << (MOREEQ - 61)) | (1L << (NOTEQUALS - 61)))) != 0)) ) {
				_localctx.op = _errHandler.RecoverInline(this);
			}
			Consume();
			State = 364; _localctx.right = formatElement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArithConditionContext : ParserRuleContext {
		public ArithExprContext left;
		public IToken op;
		public ArithExprContext right;
		public ITerminalNode MORE() { return GetToken(PftParser.MORE, 0); }
		public ITerminalNode LESSEQ() { return GetToken(PftParser.LESSEQ, 0); }
		public ArithExprContext arithExpr(int i) {
			return GetRuleContext<ArithExprContext>(i);
		}
		public ITerminalNode EQUALS() { return GetToken(PftParser.EQUALS, 0); }
		public ITerminalNode LESS() { return GetToken(PftParser.LESS, 0); }
		public ArithExprContext[] arithExpr() {
			return GetRuleContexts<ArithExprContext>();
		}
		public ITerminalNode MOREEQ() { return GetToken(PftParser.MOREEQ, 0); }
		public ITerminalNode NOTEQUALS() { return GetToken(PftParser.NOTEQUALS, 0); }
		public ArithConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arithCondition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterArithCondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitArithCondition(this);
		}
	}

	[RuleVersion(0)]
	public ArithConditionContext arithCondition() {
		ArithConditionContext _localctx = new ArithConditionContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_arithCondition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 366; _localctx.left = arithExpr(0);
			State = 367;
			_localctx.op = _input.Lt(1);
			_la = _input.La(1);
			if ( !(((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (EQUALS - 65)) | (1L << (LESS - 65)) | (1L << (LESSEQ - 65)) | (1L << (MORE - 65)) | (1L << (MOREEQ - 65)) | (1L << (NOTEQUALS - 65)))) != 0)) ) {
				_localctx.op = _errHandler.RecoverInline(this);
			}
			Consume();
			State = 368; _localctx.right = arithExpr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArithExprContext : ParserRuleContext {
		public ArithExprContext left;
		public IToken op;
		public ArithExprContext right;
		public ArithExprContext arithExpr(int i) {
			return GetRuleContext<ArithExprContext>(i);
		}
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ITerminalNode MINUS() { return GetToken(PftParser.MINUS, 0); }
		public ArithExprContext[] arithExpr() {
			return GetRuleContexts<ArithExprContext>();
		}
		public ITerminalNode STAR() { return GetToken(PftParser.STAR, 0); }
		public ITerminalNode PLUS() { return GetToken(PftParser.PLUS, 0); }
		public ITerminalNode SLASH() { return GetToken(PftParser.SLASH, 0); }
		public ArithExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arithExpr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterArithExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitArithExpr(this);
		}
	}

	[RuleVersion(0)]
	public ArithExprContext arithExpr() {
		return arithExpr(0);
	}

	private ArithExprContext arithExpr(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ArithExprContext _localctx = new ArithExprContext(_ctx, _parentState);
		ArithExprContext _prevctx = _localctx;
		int _startState = 22;
		EnterRecursionRule(_localctx, 22, RULE_arithExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 371; value();
			}
			_ctx.stop = _input.Lt(-1);
			State = 381;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,18,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 379;
					switch ( Interpreter.AdaptivePredict(_input,17,_ctx) ) {
					case 1:
						{
						_localctx = new ArithExprContext(_parentctx, _parentState);
						_localctx.left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_arithExpr);
						State = 373;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 374;
						_localctx.op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==SLASH || _la==STAR) ) {
							_localctx.op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 375; _localctx.right = arithExpr(4);
						}
						break;

					case 2:
						{
						_localctx = new ArithExprContext(_parentctx, _parentState);
						_localctx.left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_arithExpr);
						State = 376;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 377;
						_localctx.op = _input.Lt(1);
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
							_localctx.op = _errHandler.RecoverInline(this);
						}
						Consume();
						State = 378; _localctx.right = arithExpr(3);
						}
						break;
					}
					} 
				}
				State = 383;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,18,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
	 
		public ValueContext() { }
		public virtual void CopyFrom(ValueContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ArithFunctionOuterContext : ValueContext {
		public ArithFunctionContext arithFunction() {
			return GetRuleContext<ArithFunctionContext>(0);
		}
		public ArithFunctionOuterContext(ValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterArithFunctionOuter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitArithFunctionOuter(this);
		}
	}
	public partial class IntegerValueContext : ValueContext {
		public ITerminalNode SIGNED() { return GetToken(PftParser.SIGNED, 0); }
		public IntegerValueContext(ValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterIntegerValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitIntegerValue(this);
		}
	}
	public partial class ParenthesisExpressionContext : ValueContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ArithExprContext arithExpr() {
			return GetRuleContext<ArithExprContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ParenthesisExpressionContext(ValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterParenthesisExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitParenthesisExpression(this);
		}
	}
	public partial class MinusExpressionContext : ValueContext {
		public ITerminalNode MINUS() { return GetToken(PftParser.MINUS, 0); }
		public ArithExprContext arithExpr() {
			return GetRuleContext<ArithExprContext>(0);
		}
		public MinusExpressionContext(ValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMinusExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMinusExpression(this);
		}
	}
	public partial class FloatValueContext : ValueContext {
		public ITerminalNode FLOAT() { return GetToken(PftParser.FLOAT, 0); }
		public FloatValueContext(ValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFloatValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFloatValue(this);
		}
	}
	public partial class MfnValueContext : ValueContext {
		public ITerminalNode MFN() { return GetToken(PftParser.MFN, 0); }
		public MfnValueContext(ValueContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterMfnValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitMfnValue(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_value);
		try {
			State = 394;
			switch (_input.La(1)) {
			case FLOAT:
				_localctx = new FloatValueContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 384; Match(FLOAT);
				}
				break;
			case SIGNED:
				_localctx = new IntegerValueContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 385; Match(SIGNED);
				}
				break;
			case MINUS:
				_localctx = new MinusExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 386; Match(MINUS);
				State = 387; arithExpr(0);
				}
				break;
			case LPAREN:
				_localctx = new ParenthesisExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 388; Match(LPAREN);
				State = 389; arithExpr(0);
				State = 390; Match(RPAREN);
				}
				break;
			case T__31:
			case T__23:
			case L:
			case RAVR:
			case RMAX:
			case RMIN:
			case RSUM:
			case VAL:
				_localctx = new ArithFunctionOuterContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 392; arithFunction();
				}
				break;
			case MFN:
				_localctx = new MfnValueContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 393; Match(MFN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArithFunctionContext : ParserRuleContext {
		public ArithFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arithFunction; } }
	 
		public ArithFunctionContext() { }
		public virtual void CopyFrom(ArithFunctionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ValFunctionContext : ArithFunctionContext {
		public ITerminalNode VAL() { return GetToken(PftParser.VAL, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ValFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterValFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitValFunction(this);
		}
	}
	public partial class NpostFunctionContext : ArithFunctionContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode FIELD() { return GetToken(PftParser.FIELD, 0); }
		public NpostFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterNpostFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitNpostFunction(this);
		}
	}
	public partial class RavrFunctionContext : ArithFunctionContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RAVR() { return GetToken(PftParser.RAVR, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RavrFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRavrFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRavrFunction(this);
		}
	}
	public partial class RmaxFunctionContext : ArithFunctionContext {
		public ITerminalNode RMAX() { return GetToken(PftParser.RMAX, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RmaxFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRmaxFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRmaxFunction(this);
		}
	}
	public partial class SizeFunctionContext : ArithFunctionContext {
		public NonGroupedContext text;
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public SizeFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterSizeFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitSizeFunction(this);
		}
	}
	public partial class LFunctionContext : ArithFunctionContext {
		public ITerminalNode L() { return GetToken(PftParser.L, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public LFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterLFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitLFunction(this);
		}
	}
	public partial class RminFunctionContext : ArithFunctionContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode RMIN() { return GetToken(PftParser.RMIN, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RminFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRminFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRminFunction(this);
		}
	}
	public partial class RsumFunctionContext : ArithFunctionContext {
		public ITerminalNode RSUM() { return GetToken(PftParser.RSUM, 0); }
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public NonGroupedContext nonGrouped() {
			return GetRuleContext<NonGroupedContext>(0);
		}
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public RsumFunctionContext(ArithFunctionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterRsumFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitRsumFunction(this);
		}
	}

	[RuleVersion(0)]
	public ArithFunctionContext arithFunction() {
		ArithFunctionContext _localctx = new ArithFunctionContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_arithFunction);
		try {
			State = 435;
			switch (_input.La(1)) {
			case RSUM:
				_localctx = new RsumFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 396; Match(RSUM);
				State = 397; Match(LPAREN);
				State = 398; nonGrouped();
				State = 399; Match(RPAREN);
				}
				break;
			case RMAX:
				_localctx = new RmaxFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 401; Match(RMAX);
				State = 402; Match(LPAREN);
				State = 403; nonGrouped();
				State = 404; Match(RPAREN);
				}
				break;
			case RMIN:
				_localctx = new RminFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 406; Match(RMIN);
				State = 407; Match(LPAREN);
				State = 408; nonGrouped();
				State = 409; Match(RPAREN);
				}
				break;
			case RAVR:
				_localctx = new RavrFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 411; Match(RAVR);
				State = 412; Match(LPAREN);
				State = 413; nonGrouped();
				State = 414; Match(RPAREN);
				}
				break;
			case VAL:
				_localctx = new ValFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 416; Match(VAL);
				State = 417; Match(LPAREN);
				State = 418; nonGrouped();
				State = 419; Match(RPAREN);
				}
				break;
			case L:
				_localctx = new LFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 421; Match(L);
				State = 422; Match(LPAREN);
				State = 423; nonGrouped();
				State = 424; Match(RPAREN);
				}
				break;
			case T__31:
				_localctx = new NpostFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 426; Match(T__31);
				State = 427; Match(LPAREN);
				State = 428; Match(FIELD);
				State = 429; Match(RPAREN);
				}
				break;
			case T__23:
				_localctx = new SizeFunctionContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 430; Match(T__23);
				State = 431; Match(LPAREN);
				State = 432; ((SizeFunctionContext)_localctx).text = nonGrouped();
				State = 433; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FieldPresenseContext : ParserRuleContext {
		public ITerminalNode RPAREN() { return GetToken(PftParser.RPAREN, 0); }
		public ITerminalNode A() { return GetToken(PftParser.A, 0); }
		public ITerminalNode LPAREN() { return GetToken(PftParser.LPAREN, 0); }
		public ITerminalNode FIELD() { return GetToken(PftParser.FIELD, 0); }
		public ITerminalNode P() { return GetToken(PftParser.P, 0); }
		public FieldPresenseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fieldPresense; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.EnterFieldPresense(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPftListener typedListener = listener as IPftListener;
			if (typedListener != null) typedListener.ExitFieldPresense(this);
		}
	}

	[RuleVersion(0)]
	public FieldPresenseContext fieldPresense() {
		FieldPresenseContext _localctx = new FieldPresenseContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_fieldPresense);
		try {
			State = 445;
			switch (_input.La(1)) {
			case P:
				EnterOuterAlt(_localctx, 1);
				{
				State = 437; Match(P);
				State = 438; Match(LPAREN);
				State = 439; Match(FIELD);
				State = 440; Match(RPAREN);
				}
				break;
			case A:
				EnterOuterAlt(_localctx, 2);
				{
				State = 441; Match(A);
				State = 442; Match(LPAREN);
				State = 443; Match(FIELD);
				State = 444; Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 8: return condition_sempred((ConditionContext)_localctx, predIndex);

		case 11: return arithExpr_sempred((ArithExprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool condition_sempred(ConditionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 6);
		}
		return true;
	}
	private bool arithExpr_sempred(ArithExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(_ctx, 3);

		case 2: return Precpred(_ctx, 2);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3l\x1C2\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x3\x2\a\x2\"\n\x2\f\x2\xE\x2%\v\x2\x3\x2\x3\x2\x3\x3\x3\x3\x5\x3"+
		"+\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x6\x5\x32\n\x5\r\x5\xE\x5\x33\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x5\x6\x66\n\x6\x5\x6h\n\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\x12F\n\x6\x3\a\x3"+
		"\a\x5\a\x133\n\a\x3\a\a\a\x136\n\a\f\a\xE\a\x139\v\a\x3\b\x5\b\x13C\n"+
		"\b\x3\b\x3\b\a\b\x140\n\b\f\b\xE\b\x143\v\b\x3\t\x3\t\x3\t\x3\t\a\t\x149"+
		"\n\t\f\t\xE\t\x14C\v\t\x3\t\x3\t\a\t\x150\n\t\f\t\xE\t\x153\v\t\x5\t\x155"+
		"\n\t\x3\t\x3\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x5\n"+
		"\x163\n\n\x3\n\x3\n\x3\n\a\n\x168\n\n\f\n\xE\n\x16B\v\n\x3\v\x3\v\x3\v"+
		"\x3\v\x3\f\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r"+
		"\a\r\x17E\n\r\f\r\xE\r\x181\v\r\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x5\xE\x18D\n\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF"+
		"\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3"+
		"\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF"+
		"\x1B6\n\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x5"+
		"\x10\x1C0\n\x10\x3\x10\x2\x2\x4\x12\x18\x11\x2\x2\x4\x2\x6\x2\b\x2\n\x2"+
		"\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2\x2"+
		"\a\x4\x2;;WW\a\x2??\x43\x43MNRSVV\x6\x2\x43\x43MNRSVV\x3\x2\x63\x64\x4"+
		"\x2QQZZ\x219\x2#\x3\x2\x2\x2\x4*\x3\x2\x2\x2\x6,\x3\x2\x2\x2\b\x31\x3"+
		"\x2\x2\x2\n\x12E\x3\x2\x2\x2\f\x137\x3\x2\x2\x2\xE\x141\x3\x2\x2\x2\x10"+
		"\x144\x3\x2\x2\x2\x12\x162\x3\x2\x2\x2\x14\x16C\x3\x2\x2\x2\x16\x170\x3"+
		"\x2\x2\x2\x18\x174\x3\x2\x2\x2\x1A\x18C\x3\x2\x2\x2\x1C\x1B5\x3\x2\x2"+
		"\x2\x1E\x1BF\x3\x2\x2\x2 \"\x5\x4\x3\x2! \x3\x2\x2\x2\"%\x3\x2\x2\x2#"+
		"!\x3\x2\x2\x2#$\x3\x2\x2\x2$&\x3\x2\x2\x2%#\x3\x2\x2\x2&\'\a\x2\x2\x3"+
		"\'\x3\x3\x2\x2\x2(+\x5\b\x5\x2)+\x5\x6\x4\x2*(\x3\x2\x2\x2*)\x3\x2\x2"+
		"\x2+\x5\x3\x2\x2\x2,-\aO\x2\x2-.\x5\b\x5\x2./\a_\x2\x2/\a\x3\x2\x2\x2"+
		"\x30\x32\x5\n\x6\x2\x31\x30\x3\x2\x2\x2\x32\x33\x3\x2\x2\x2\x33\x31\x3"+
		"\x2\x2\x2\x33\x34\x3\x2\x2\x2\x34\t\x3\x2\x2\x2\x35\x12F\x5\x10\t\x2\x36"+
		"\x37\x5\f\a\x2\x37\x38\a\x33\x2\x2\x38\x39\x5\xE\b\x2\x39\x12F\x3\x2\x2"+
		"\x2:;\a,\x2\x2;<\aO\x2\x2<=\x5\b\x5\x2=>\a_\x2\x2>\x12F\x3\x2\x2\x2?@"+
		"\a\x44\x2\x2@\x41\aO\x2\x2\x41\x42\x5\b\x5\x2\x42\x43\a_\x2\x2\x43\x12F"+
		"\x3\x2\x2\x2\x44\x45\aj\x2\x2\x45\x46\aO\x2\x2\x46G\x5\b\x5\x2GH\a_\x2"+
		"\x2H\x12F\x3\x2\x2\x2IJ\a\x46\x2\x2JK\aO\x2\x2KL\x5\b\x5\x2LM\a_\x2\x2"+
		"M\x12F\x3\x2\x2\x2NO\ag\x2\x2OP\aO\x2\x2PQ\x5\b\x5\x2QR\a_\x2\x2R\x12F"+
		"\x3\x2\x2\x2ST\a\x41\x2\x2TU\aO\x2\x2UV\x5\b\x5\x2VW\a_\x2\x2W\x12F\x3"+
		"\x2\x2\x2X\x12F\a=\x2\x2YZ\a\x61\x2\x2Z[\aO\x2\x2[\\\x5\b\x5\x2\\]\a_"+
		"\x2\x2]\x12F\x3\x2\x2\x2^_\a\x45\x2\x2_`\aO\x2\x2`g\x5\x18\r\x2\x61\x62"+
		"\a@\x2\x2\x62\x65\x5\x18\r\x2\x63\x64\a@\x2\x2\x64\x66\x5\x18\r\x2\x65"+
		"\x63\x3\x2\x2\x2\x65\x66\x3\x2\x2\x2\x66h\x3\x2\x2\x2g\x61\x3\x2\x2\x2"+
		"gh\x3\x2\x2\x2hi\x3\x2\x2\x2ij\a_\x2\x2j\x12F\x3\x2\x2\x2kl\a\\\x2\x2"+
		"lm\aO\x2\x2mn\x5\x18\r\x2no\a@\x2\x2op\x5\b\x5\x2pq\a_\x2\x2q\x12F\x3"+
		"\x2\x2\x2rs\ah\x2\x2st\aO\x2\x2tu\x5\b\x5\x2uv\a_\x2\x2v\x12F\x3\x2\x2"+
		"\x2w\x12F\aJ\x2\x2x\x12F\aT\x2\x2yz\aT\x2\x2z{\aO\x2\x2{|\a\x33\x2\x2"+
		"|\x12F\a_\x2\x2}\x12F\a.\x2\x2~\x12F\a/\x2\x2\x7F\x12F\a>\x2\x2\x80\x12F"+
		"\a\x34\x2\x2\x81\x12F\a\x30\x2\x2\x82\x12F\aP\x2\x2\x83\x12F\a\x36\x2"+
		"\x2\x84\x12F\a@\x2\x2\x85\x12F\a\x63\x2\x2\x86\x12F\aH\x2\x2\x87\x12F"+
		"\aY\x2\x2\x88\x12F\a\x35\x2\x2\x89\x12F\a\x38\x2\x2\x8A\x12F\a\x39\x2"+
		"\x2\x8B\x8C\a\x11\x2\x2\x8C\x8D\aO\x2\x2\x8D\x8E\a\x30\x2\x2\x8E\x12F"+
		"\a_\x2\x2\x8F\x90\a\'\x2\x2\x90\x91\aO\x2\x2\x91\x92\a\x30\x2\x2\x92\x93"+
		"\a@\x2\x2\x93\x94\x5\b\x5\x2\x94\x95\a_\x2\x2\x95\x12F\x3\x2\x2\x2\x96"+
		"\x97\a\f\x2\x2\x97\x98\aO\x2\x2\x98\x99\x5\b\x5\x2\x99\x9A\a_\x2\x2\x9A"+
		"\x12F\x3\x2\x2\x2\x9B\x12F\a\x15\x2\x2\x9C\x12F\a\x16\x2\x2\x9D\x12F\a"+
		" \x2\x2\x9E\x12F\a\x5\x2\x2\x9F\x12F\a(\x2\x2\xA0\x12F\a\x17\x2\x2\xA1"+
		"\x12F\a\x1A\x2\x2\xA2\x12F\a\x1E\x2\x2\xA3\xA4\a&\x2\x2\xA4\xA5\aO\x2"+
		"\x2\xA5\xA6\a\x30\x2\x2\xA6\x12F\a_\x2\x2\xA7\xA8\a\xE\x2\x2\xA8\xA9\a"+
		"O\x2\x2\xA9\xAA\a\x30\x2\x2\xAA\x12F\a_\x2\x2\xAB\xAC\a\x4\x2\x2\xAC\xAD"+
		"\aO\x2\x2\xAD\xAE\x5\b\x5\x2\xAE\xAF\a@\x2\x2\xAF\xB0\a+\x2\x2\xB0\xB1"+
		"\a_\x2\x2\xB1\x12F\x3\x2\x2\x2\xB2\xB3\a\r\x2\x2\xB3\xB4\aO\x2\x2\xB4"+
		"\xB5\x5\b\x5\x2\xB5\xB6\a@\x2\x2\xB6\xB7\a+\x2\x2\xB7\xB8\a@\x2\x2\xB8"+
		"\xB9\a+\x2\x2\xB9\xBA\a_\x2\x2\xBA\x12F\x3\x2\x2\x2\xBB\xBC\a%\x2\x2\xBC"+
		"\xBD\aO\x2\x2\xBD\xBE\x5\b\x5\x2\xBE\xBF\a@\x2\x2\xBF\xC0\a+\x2\x2\xC0"+
		"\xC1\a_\x2\x2\xC1\x12F\x3\x2\x2\x2\xC2\xC3\a\x1D\x2\x2\xC3\xC4\aO\x2\x2"+
		"\xC4\xC5\x5\b\x5\x2\xC5\xC6\a_\x2\x2\xC6\x12F\x3\x2\x2\x2\xC7\xC8\a\x10"+
		"\x2\x2\xC8\xC9\aO\x2\x2\xC9\xCA\x5\b\x5\x2\xCA\xCB\a_\x2\x2\xCB\x12F\x3"+
		"\x2\x2\x2\xCC\xCD\a\t\x2\x2\xCD\xCE\aO\x2\x2\xCE\xCF\x5\b\x5\x2\xCF\xD0"+
		"\a@\x2\x2\xD0\xD1\a+\x2\x2\xD1\xD2\a_\x2\x2\xD2\x12F\x3\x2\x2\x2\xD3\xD4"+
		"\a#\x2\x2\xD4\xD5\aO\x2\x2\xD5\xD6\x5\b\x5\x2\xD6\xD7\a@\x2\x2\xD7\xD8"+
		"\a+\x2\x2\xD8\xD9\a_\x2\x2\xD9\x12F\x3\x2\x2\x2\xDA\xDB\a\v\x2\x2\xDB"+
		"\xDC\aO\x2\x2\xDC\xDD\x5\b\x5\x2\xDD\xDE\a@\x2\x2\xDE\xDF\a+\x2\x2\xDF"+
		"\xE0\a_\x2\x2\xE0\x12F\x3\x2\x2\x2\xE1\xE2\a\x6\x2\x2\xE2\xE3\aO\x2\x2"+
		"\xE3\xE4\a+\x2\x2\xE4\x12F\a_\x2\x2\xE5\xE6\a\b\x2\x2\xE6\xE7\aO\x2\x2"+
		"\xE7\xE8\a+\x2\x2\xE8\x12F\a_\x2\x2\xE9\xEA\a)\x2\x2\xEA\xEB\aO\x2\x2"+
		"\xEB\xEC\x5\b\x5\x2\xEC\xED\a_\x2\x2\xED\x12F\x3\x2\x2\x2\xEE\xEF\a\xF"+
		"\x2\x2\xEF\xF0\aO\x2\x2\xF0\xF1\x5\b\x5\x2\xF1\xF2\a_\x2\x2\xF2\x12F\x3"+
		"\x2\x2\x2\xF3\xF4\a\x18\x2\x2\xF4\xF5\aO\x2\x2\xF5\xF6\x5\b\x5\x2\xF6"+
		"\xF7\a_\x2\x2\xF7\x12F\x3\x2\x2\x2\xF8\xF9\a\x1C\x2\x2\xF9\xFA\aO\x2\x2"+
		"\xFA\xFB\x5\n\x6\x2\xFB\xFC\a@\x2\x2\xFC\xFD\x5\n\x6\x2\xFD\xFE\a@\x2"+
		"\x2\xFE\xFF\x5\n\x6\x2\xFF\x100\a_\x2\x2\x100\x12F\x3\x2\x2\x2\x101\x102"+
		"\a\"\x2\x2\x102\x103\aO\x2\x2\x103\x104\x5\b\x5\x2\x104\x105\a_\x2\x2"+
		"\x105\x12F\x3\x2\x2\x2\x106\x107\a\x1F\x2\x2\x107\x108\aO\x2\x2\x108\x109"+
		"\x5\b\x5\x2\x109\x10A\a_\x2\x2\x10A\x12F\x3\x2\x2\x2\x10B\x12F\a\x37\x2"+
		"\x2\x10C\x10D\a\x14\x2\x2\x10D\x10E\aO\x2\x2\x10E\x10F\x5\b\x5\x2\x10F"+
		"\x110\a_\x2\x2\x110\x12F\x3\x2\x2\x2\x111\x12F\a\x19\x2\x2\x112\x113\a"+
		"\x19\x2\x2\x113\x114\aO\x2\x2\x114\x115\x5\b\x5\x2\x115\x116\a_\x2\x2"+
		"\x116\x12F\x3\x2\x2\x2\x117\x12F\a\x1B\x2\x2\x118\x12F\a$\x2\x2\x119\x11A"+
		"\a$\x2\x2\x11A\x11B\aO\x2\x2\x11B\x11C\x5\b\x5\x2\x11C\x11D\a_\x2\x2\x11D"+
		"\x12F\x3\x2\x2\x2\x11E\x11F\a!\x2\x2\x11F\x120\aO\x2\x2\x120\x121\x5\b"+
		"\x5\x2\x121\x122\a_\x2\x2\x122\x12F\x3\x2\x2\x2\x123\x124\a\x13\x2\x2"+
		"\x124\x125\aO\x2\x2\x125\x126\x5\b\x5\x2\x126\x127\a_\x2\x2\x127\x12F"+
		"\x3\x2\x2\x2\x128\x129\a\a\x2\x2\x129\x12A\aO\x2\x2\x12A\x12B\x5\b\x5"+
		"\x2\x12B\x12C\a_\x2\x2\x12C\x12F\x3\x2\x2\x2\x12D\x12F\a\x3\x2\x2\x12E"+
		"\x35\x3\x2\x2\x2\x12E\x36\x3\x2\x2\x2\x12E:\x3\x2\x2\x2\x12E?\x3\x2\x2"+
		"\x2\x12E\x44\x3\x2\x2\x2\x12EI\x3\x2\x2\x2\x12EN\x3\x2\x2\x2\x12ES\x3"+
		"\x2\x2\x2\x12EX\x3\x2\x2\x2\x12EY\x3\x2\x2\x2\x12E^\x3\x2\x2\x2\x12Ek"+
		"\x3\x2\x2\x2\x12Er\x3\x2\x2\x2\x12Ew\x3\x2\x2\x2\x12Ex\x3\x2\x2\x2\x12E"+
		"y\x3\x2\x2\x2\x12E}\x3\x2\x2\x2\x12E~\x3\x2\x2\x2\x12E\x7F\x3\x2\x2\x2"+
		"\x12E\x80\x3\x2\x2\x2\x12E\x81\x3\x2\x2\x2\x12E\x82\x3\x2\x2\x2\x12E\x83"+
		"\x3\x2\x2\x2\x12E\x84\x3\x2\x2\x2\x12E\x85\x3\x2\x2\x2\x12E\x86\x3\x2"+
		"\x2\x2\x12E\x87\x3\x2\x2\x2\x12E\x88\x3\x2\x2\x2\x12E\x89\x3\x2\x2\x2"+
		"\x12E\x8A\x3\x2\x2\x2\x12E\x8B\x3\x2\x2\x2\x12E\x8F\x3\x2\x2\x2\x12E\x96"+
		"\x3\x2\x2\x2\x12E\x9B\x3\x2\x2\x2\x12E\x9C\x3\x2\x2\x2\x12E\x9D\x3\x2"+
		"\x2\x2\x12E\x9E\x3\x2\x2\x2\x12E\x9F\x3\x2\x2\x2\x12E\xA0\x3\x2\x2\x2"+
		"\x12E\xA1\x3\x2\x2\x2\x12E\xA2\x3\x2\x2\x2\x12E\xA3\x3\x2\x2\x2\x12E\xA7"+
		"\x3\x2\x2\x2\x12E\xAB\x3\x2\x2\x2\x12E\xB2\x3\x2\x2\x2\x12E\xBB\x3\x2"+
		"\x2\x2\x12E\xC2\x3\x2\x2\x2\x12E\xC7\x3\x2\x2\x2\x12E\xCC\x3\x2\x2\x2"+
		"\x12E\xD3\x3\x2\x2\x2\x12E\xDA\x3\x2\x2\x2\x12E\xE1\x3\x2\x2\x2\x12E\xE5"+
		"\x3\x2\x2\x2\x12E\xE9\x3\x2\x2\x2\x12E\xEE\x3\x2\x2\x2\x12E\xF3\x3\x2"+
		"\x2\x2\x12E\xF8\x3\x2\x2\x2\x12E\x101\x3\x2\x2\x2\x12E\x106\x3\x2\x2\x2"+
		"\x12E\x10B\x3\x2\x2\x2\x12E\x10C\x3\x2\x2\x2\x12E\x111\x3\x2\x2\x2\x12E"+
		"\x112\x3\x2\x2\x2\x12E\x117\x3\x2\x2\x2\x12E\x118\x3\x2\x2\x2\x12E\x119"+
		"\x3\x2\x2\x2\x12E\x11E\x3\x2\x2\x2\x12E\x123\x3\x2\x2\x2\x12E\x128\x3"+
		"\x2\x2\x2\x12E\x12D\x3\x2\x2\x2\x12F\v\x3\x2\x2\x2\x130\x132\a\x32\x2"+
		"\x2\x131\x133\aZ\x2\x2\x132\x131\x3\x2\x2\x2\x132\x133\x3\x2\x2\x2\x133"+
		"\x136\x3\x2\x2\x2\x134\x136\a\x31\x2\x2\x135\x130\x3\x2\x2\x2\x135\x134"+
		"\x3\x2\x2\x2\x136\x139\x3\x2\x2\x2\x137\x135\x3\x2\x2\x2\x137\x138\x3"+
		"\x2\x2\x2\x138\r\x3\x2\x2\x2\x139\x137\x3\x2\x2\x2\x13A\x13C\aZ\x2\x2"+
		"\x13B\x13A\x3\x2\x2\x2\x13B\x13C\x3\x2\x2\x2\x13C\x13D\x3\x2\x2\x2\x13D"+
		"\x140\a\x32\x2\x2\x13E\x140\a\x31\x2\x2\x13F\x13B\x3\x2\x2\x2\x13F\x13E"+
		"\x3\x2\x2\x2\x140\x143\x3\x2\x2\x2\x141\x13F\x3\x2\x2\x2\x141\x142\x3"+
		"\x2\x2\x2\x142\xF\x3\x2\x2\x2\x143\x141\x3\x2\x2\x2\x144\x145\aI\x2\x2"+
		"\x145\x146\x5\x12\n\x2\x146\x14A\a\x65\x2\x2\x147\x149\x5\x4\x3\x2\x148"+
		"\x147\x3\x2\x2\x2\x149\x14C\x3\x2\x2\x2\x14A\x148\x3\x2\x2\x2\x14A\x14B"+
		"\x3\x2\x2\x2\x14B\x154\x3\x2\x2\x2\x14C\x14A\x3\x2\x2\x2\x14D\x151\a\x42"+
		"\x2\x2\x14E\x150\x5\x4\x3\x2\x14F\x14E\x3\x2\x2\x2\x150\x153\x3\x2\x2"+
		"\x2\x151\x14F\x3\x2\x2\x2\x151\x152\x3\x2\x2\x2\x152\x155\x3\x2\x2\x2"+
		"\x153\x151\x3\x2\x2\x2\x154\x14D\x3\x2\x2\x2\x154\x155\x3\x2\x2\x2\x155"+
		"\x156\x3\x2\x2\x2\x156\x157\aG\x2\x2\x157\x11\x3\x2\x2\x2\x158\x159\b"+
		"\n\x1\x2\x159\x15A\aU\x2\x2\x15A\x163\x5\x12\n\a\x15B\x15C\aO\x2\x2\x15C"+
		"\x15D\x5\x12\n\x2\x15D\x15E\a_\x2\x2\x15E\x163\x3\x2\x2\x2\x15F\x163\x5"+
		"\x14\v\x2\x160\x163\x5\x1E\x10\x2\x161\x163\x5\x16\f\x2\x162\x158\x3\x2"+
		"\x2\x2\x162\x15B\x3\x2\x2\x2\x162\x15F\x3\x2\x2\x2\x162\x160\x3\x2\x2"+
		"\x2\x162\x161\x3\x2\x2\x2\x163\x169\x3\x2\x2\x2\x164\x165\f\b\x2\x2\x165"+
		"\x166\t\x2\x2\x2\x166\x168\x5\x12\n\t\x167\x164\x3\x2\x2\x2\x168\x16B"+
		"\x3\x2\x2\x2\x169\x167\x3\x2\x2\x2\x169\x16A\x3\x2\x2\x2\x16A\x13\x3\x2"+
		"\x2\x2\x16B\x169\x3\x2\x2\x2\x16C\x16D\x5\n\x6\x2\x16D\x16E\t\x3\x2\x2"+
		"\x16E\x16F\x5\n\x6\x2\x16F\x15\x3\x2\x2\x2\x170\x171\x5\x18\r\x2\x171"+
		"\x172\t\x4\x2\x2\x172\x173\x5\x18\r\x2\x173\x17\x3\x2\x2\x2\x174\x175"+
		"\b\r\x1\x2\x175\x176\x5\x1A\xE\x2\x176\x17F\x3\x2\x2\x2\x177\x178\f\x5"+
		"\x2\x2\x178\x179\t\x5\x2\x2\x179\x17E\x5\x18\r\x6\x17A\x17B\f\x4\x2\x2"+
		"\x17B\x17C\t\x6\x2\x2\x17C\x17E\x5\x18\r\x5\x17D\x177\x3\x2\x2\x2\x17D"+
		"\x17A\x3\x2\x2\x2\x17E\x181\x3\x2\x2\x2\x17F\x17D\x3\x2\x2\x2\x17F\x180"+
		"\x3\x2\x2\x2\x180\x19\x3\x2\x2\x2\x181\x17F\x3\x2\x2\x2\x182\x18D\a-\x2"+
		"\x2\x183\x18D\a*\x2\x2\x184\x185\aQ\x2\x2\x185\x18D\x5\x18\r\x2\x186\x187"+
		"\aO\x2\x2\x187\x188\x5\x18\r\x2\x188\x189\a_\x2\x2\x189\x18D\x3\x2\x2"+
		"\x2\x18A\x18D\x5\x1C\xF\x2\x18B\x18D\aP\x2\x2\x18C\x182\x3\x2\x2\x2\x18C"+
		"\x183\x3\x2\x2\x2\x18C\x184\x3\x2\x2\x2\x18C\x186\x3\x2\x2\x2\x18C\x18A"+
		"\x3\x2\x2\x2\x18C\x18B\x3\x2\x2\x2\x18D\x1B\x3\x2\x2\x2\x18E\x18F\a`\x2"+
		"\x2\x18F\x190\aO\x2\x2\x190\x191\x5\b\x5\x2\x191\x192\a_\x2\x2\x192\x1B6"+
		"\x3\x2\x2\x2\x193\x194\a]\x2\x2\x194\x195\aO\x2\x2\x195\x196\x5\b\x5\x2"+
		"\x196\x197\a_\x2\x2\x197\x1B6\x3\x2\x2\x2\x198\x199\a^\x2\x2\x199\x19A"+
		"\aO\x2\x2\x19A\x19B\x5\b\x5\x2\x19B\x19C\a_\x2\x2\x19C\x1B6\x3\x2\x2\x2"+
		"\x19D\x19E\a[\x2\x2\x19E\x19F\aO\x2\x2\x19F\x1A0\x5\b\x5\x2\x1A0\x1A1"+
		"\a_\x2\x2\x1A1\x1B6\x3\x2\x2\x2\x1A2\x1A3\ai\x2\x2\x1A3\x1A4\aO\x2\x2"+
		"\x1A4\x1A5\x5\b\x5\x2\x1A5\x1A6\a_\x2\x2\x1A6\x1B6\x3\x2\x2\x2\x1A7\x1A8"+
		"\aK\x2\x2\x1A8\x1A9\aO\x2\x2\x1A9\x1AA\x5\b\x5\x2\x1AA\x1AB\a_\x2\x2\x1AB"+
		"\x1B6\x3\x2\x2\x2\x1AC\x1AD\a\n\x2\x2\x1AD\x1AE\aO\x2\x2\x1AE\x1AF\a\x33"+
		"\x2\x2\x1AF\x1B6\a_\x2\x2\x1B0\x1B1\a\x12\x2\x2\x1B1\x1B2\aO\x2\x2\x1B2"+
		"\x1B3\x5\b\x5\x2\x1B3\x1B4\a_\x2\x2\x1B4\x1B6\x3\x2\x2\x2\x1B5\x18E\x3"+
		"\x2\x2\x2\x1B5\x193\x3\x2\x2\x2\x1B5\x198\x3\x2\x2\x2\x1B5\x19D\x3\x2"+
		"\x2\x2\x1B5\x1A2\x3\x2\x2\x2\x1B5\x1A7\x3\x2\x2\x2\x1B5\x1AC\x3\x2\x2"+
		"\x2\x1B5\x1B0\x3\x2\x2\x2\x1B6\x1D\x3\x2\x2\x2\x1B7\x1B8\aX\x2\x2\x1B8"+
		"\x1B9\aO\x2\x2\x1B9\x1BA\a\x33\x2\x2\x1BA\x1C0\a_\x2\x2\x1BB\x1BC\a:\x2"+
		"\x2\x1BC\x1BD\aO\x2\x2\x1BD\x1BE\a\x33\x2\x2\x1BE\x1C0\a_\x2\x2\x1BF\x1B7"+
		"\x3\x2\x2\x2\x1BF\x1BB\x3\x2\x2\x2\x1C0\x1F\x3\x2\x2\x2\x18#*\x33\x65"+
		"g\x12E\x132\x135\x137\x13B\x13F\x141\x14A\x151\x154\x162\x169\x17D\x17F"+
		"\x18C\x1B5\x1BF";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace ManagedClient.Pft
